class Serialized
{
protected:
	const char categoryDelim = '~';
	const char elemDelim = '|';
	const std::string delims = "~|";

	void destroy();
	void innerClear();


	//Vector of (Vector of Strings)pointers for de/serializing
	std::vector<std::vector<std::string>*> vecVec;

	std::string serialized;

	std::vector<std::string> type;

	virtual void setType() = 0;
	virtual void loadVecs() = 0;
	virtual void build() = 0;

public:
	Serialized();
	~Serialized();

	void setSerialized(std::string);
	std::string getSerialized();

	virtual void serialize();
	virtual void deserialize();
	virtual void deserialize(std::string);

	virtual void print() = 0;
};

#include <iostream>
#include <limits>

Serialized::Serialized()
{

}

Serialized::~Serialized()
{

}

void Serialized::setSerialized(std::string _serialized)
{
	serialized = _serialized;
}

std::string Serialized::getSerialized()
{
	return serialized;
}

void Serialized::serialize() 
{
	std::vector<std::string>::iterator vecIt;
	std::vector<std::vector<std::string>*>::iterator vecVecIt;

	//Iterate over outter vector adding category delimiter after each inner vector
	for (vecVecIt = vecVec.begin(); vecVecIt != vecVec.end(); ++vecVecIt)
	{
		//Iterate over inner vectors, adding element delimiter after each string 
		//for (vecIt = (*vecVecIt)->begin(); vecIt != (*vecVecIt)->end(); ++vecIt)
		vecIt = (*vecVecIt)->begin();
		while (vecIt != (*vecVecIt)->end())
		{
			serialized += *vecIt + elemDelim;
			vecIt++;
		}
		serialized += categoryDelim;
	}
}

void Serialized::deserialize()
{
	if (!serialized.empty())
	{
		//Iterators for maneuvering throuhgh data
		std::vector<std::string>::iterator vecIt;
		std::vector<std::vector<std::string>*>::iterator vecVecIt;

		vecVecIt = vecVec.begin();
		vecIt = (*vecVecIt)->begin();

		//Make sure the container is empty
		innerClear();

		//Make a string of delimiters for searching purposes
		std::string delims;
		delims.push_back(categoryDelim);
		delims.push_back(elemDelim);

		//Delimiter placeholders
		//innerNext and outterNext are assigned the position of the delimiter
		//innerPrev and outterPrev are first used to calculate the length of the element by (next - prev)
		//innerPrev and outterPrev are then set to the first character AFTER the previous delimiter
		//and become the next starting point for a substring search
		size_t innerPrev = 0;
		size_t innerNext = 0;

		size_t outterPrev = 0;
		size_t outterNext = 0;

		size_t elemStart;
		size_t elemLength;
		size_t offset;		 //difference between innerPrev and next non-delim character

		//Check to see whether there is another category delimter after the previous
		while ((outterNext = serialized.find_first_of(categoryDelim, outterPrev)) != std::string::npos)
		{
			//Check to see whether there are more characters or category delimiters after the previous
			while ((innerNext = serialized.find_first_of(elemDelim, innerPrev)) != std::string::npos && (innerNext < serialized.find_first_of(categoryDelim, outterPrev)))
			{
				//find where the actual element string exists
				elemStart = serialized.find_first_not_of(delims, innerPrev);
				offset = elemStart - innerPrev;
				elemLength = innerNext - innerPrev - offset;

				//Add the element to the current inner vector
				(*vecVecIt)->push_back(serialized.substr(elemStart, elemLength));
				innerPrev = innerNext + 1;
			}
			//Advance to the next category delimiter and inner vector
			outterPrev = outterNext + 1;
			if (vecVecIt != vecVec.end())
				vecVecIt++;
		}
	}
}

void Serialized::deserialize(std::string _serialized)
{
	setSerialized(_serialized);
	deserialize();
}

void Serialized::innerClear()
{
	std::vector<std::string>::iterator vecIt;
	std::vector<std::vector<std::string>*>::iterator vecVecIt;

	//Clear all inner vectors, leaving data structure
	for (vecVecIt = vecVec.begin(); vecVecIt != vecVec.end(); vecVecIt++)
	{
		(*vecVecIt)->clear();
	}
}

void Serialized::destroy()
{
	innerClear();
	vecVec.clear();
}

void Serialized::build()
{
	
}
