#include <vector>
#include <iostream>
#include <limits>

using namespace std;

class Serialized
{
protected:
	const char outerDelimiter = '~';
	const char innerDelimiter = '|';
	const string delims = "~|";

	void destroy();
	void innerClear();

	//Vector of (Vector of Strings)pointers for de/serializing
	vector<vector<string>*> outerVector;

	string serialized;

public:
	Serialized();
	~Serialized();

	void setSerialized(string);
	string getSerialized();

	virtual void serialize();
	virtual void deserialize();
	virtual void deserialize(string);

	virtual void print() = 0;
};

Serialized::Serialized()
{

}

Serialized::~Serialized()
{

}

void Serialized::setSerialized(string _serialized)
{
	serialized = _serialized;
}

string Serialized::getSerialized()
{
	return serialized;
}

void Serialized::serialize()
{
	vector<string>::iterator innerIterator;
	vector<vector<string>*>::iterator outerIterator;

	//Iterate over outter vector adding category delimiter after each inner vector
	for (outerIterator = outerVector.begin(); outerIterator != outerVector.end(); ++outerIterator)
	{
		//Iterate over inner vectors, adding element delimiter after each string 
		innerIterator = (*outerIterator)->begin();
		while (innerIterator != (*outerIterator)->end())
		{
			serialized += *innerIterator + innerDelimiter;
			innerIterator++;
		}
		serialized += outerDelimiter;
	}
}

void Serialized::deserialize()
{
	if (serialized.empty()) {return;}
	else 
	{
		//Iterators for maneuvering through storage targets
		vector<string>::iterator innerIterator;
		vector<vector<string>*>::iterator outerIterator;

		outerIterator = outerVector.begin();
		innerIterator = (*outerIterator)->begin();

		//Make sure the container is empty
		innerClear();

		//Make a string of delimiters for searching purposes
		string delims;
		delims.push_back(outerDelimiter);
		delims.push_back(innerDelimiter);

		//Location placeholders
		size_t innerStart = 0;
		size_t innerEnd = serialized.find_first_of(innerDelimiter, innerStart);

		size_t outerStart = 0;
		size_t outerEnd = serialized.find_first_of(outerDelimiter, outerStart);

		size_t elemStart;
		size_t elemLength;
		size_t offset;		 //difference between innerStart and next non-delim character

		while (outerEnd != string::npos)
		{
			while (innerEnd != string::npos && (innerEnd < outerEnd))
			{
				//find where the actual element string exists
				elemStart = serialized.find_first_not_of(delims, innerStart);
				offset = elemStart - innerStart;
				elemLength = innerEnd - innerStart - offset;

				//Add the element to the current inner vector
				(*outerIterator)->push_back(serialized.substr(elemStart, elemLength));
				innerStart = innerEnd + 1;

				//Check to see whether there are more characters or category delimiters after the previous
				innerEnd = serialized.find_first_of(innerDelimiter, innerStart);
			}
			//Advance to the next outer delimiter and inner vector
			outerStart = outerEnd + 1;
			if (outerIterator != outerVector.end())
				outerIterator++;

		//Check to see whether there is another category delimter after the previous
		outerEnd = serialized.find_first_of(outerDelimiter, outerStart);
		}
	}
}

void Serialized::deserialize(string _serialized)
{
	setSerialized(_serialized);
	deserialize();
}

void Serialized::innerClear()
{
	vector<string>::iterator innerIterator;
	vector<vector<string>*>::iterator outerIterator;

	//Clear all inner vectors, leaving data structure
	for (outerIterator = outerVector.begin(); outerIterator != outerVector.end(); outerIterator++)
	{
		(*outerIterator)->clear();
	}
}

void Serialized::destroy()
{
	innerClear();
	outerVector.clear();
}
